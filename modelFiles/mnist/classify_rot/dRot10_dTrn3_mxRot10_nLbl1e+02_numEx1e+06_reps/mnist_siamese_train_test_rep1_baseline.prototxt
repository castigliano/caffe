name: "mnist_siamese_train_test"
######### Images ##########
layer { 
 name: "pair_data" 
 type: "Data" 
 top: "pair_data" 
 data_param { 
	  source: "/data1/pulkitag/mnist/lmdb-store/train/images_mnist_transform_classify_train_dRot10_dTrn3_mxRot10_nLbl1e+02_numEx1e+06_rep1-lmdb" 
	  batch_size: 64 
	  backend: LMDB 
 } 
 transform_param { 
	  scale: 0.00390625 
 } 
 include { 
	  phase: TRAIN 
 } 
} 
layer { 
 name: "pair_data" 
 type: "Data" 
 top: "pair_data" 
 data_param { 
	  source: "/data1/pulkitag/mnist/lmdb-store/test/images_mnist_transform_classify_test_dRot10_dTrn3_mxRot10_nLbl1e+04_numEx1e+04_rep1-lmdb" 
	  batch_size: 100 
	  backend: LMDB 
 } 
 transform_param { 
	  scale: 0.00390625 
 } 
 include { 
	  phase: TEST 
 } 
} 
layer { 
 name: "slice_pair" 
 type: "Slice" 
 bottom: "pair_data" 
 top: "data" 
 top: "data_p" 
 slice_param { 
	  slice_dim: 1 
	  slice_point: 1 
 } 
} 
layer { 
 name: "pair_labels" 
 type: "Data" 
 top: "pair_labels" 
 data_param { 
	  source:  "/data1/pulkitag/mnist/lmdb-store/train/labels_mnist_transform_classify_train_dRot10_dTrn3_mxRot10_nLbl1e+02_numEx1e+06_rep1-lmdb" 
	  batch_size: 64 
	  backend: LMDB 
 } 
 include { 
	  phase: TRAIN 
 } 
} 
layer { 
 name: "pair_labels" 
 type: "Data" 
 top: "pair_labels" 
 data_param { 
	  source:  "/data1/pulkitag/mnist/lmdb-store/test/labels_mnist_transform_classify_test_dRot10_dTrn3_mxRot10_nLbl1e+04_numEx1e+04_rep1-lmdb" 
	  batch_size: 100 
	  backend: LMDB 
 } 
 include { 
	  phase: TEST 
 } 
} 
layer { 
 name: "slice_label" 
 type: "Slice" 
 bottom: "pair_labels" 
 top: "classify_label" 
 top: "transform_label" 
 slice_param { 
	  slice_dim: 1 
	  slice_point: 1 
 } 
} 
layer { 
 name: "conv1" 
 type: "Convolution" 
 bottom: "data" 
 top: "conv1" 
 param { 
	  name: "conv1_w" 
	  lr_mult: 1 
	  decay_mult: 1 
 } 
 param { 
	  name: "conv1_b" 
	  lr_mult: 2 
	  decay_mult: 0 
 } 
 convolution_param { 
	  num_output: 20 
	  kernel_size: 5 
	  stride: 1 
	  weight_filler { 
	 	  type: "xavier" 
	  } 
	  bias_filler { 
	 	  type: "constant" 
	  } 
 } 
} 
layer { 
 name: "pool1" 
 type: "Pooling" 
 bottom: "conv1" 
 top: "pool1" 
 pooling_param { 
	  pool: MAX 
	  kernel_size: 2 
	  stride: 2 
 } 
} 
layer { 
 name: "conv2" 
 type: "Convolution" 
 bottom: "pool1" 
 top: "conv2" 
 param { 
	  name: "conv2_w" 
	  lr_mult: 1 
	  decay_mult: 1 
 } 
 param { 
	  name: "conv2_b" 
	  lr_mult: 2 
	  decay_mult: 0 
 } 
 convolution_param { 
	  num_output: 50 
	  kernel_size: 5 
	  stride: 1 
	  weight_filler { 
	 	  type: "xavier" 
	  } 
	  bias_filler { 
	 	  type: "constant" 
	  } 
 } 
} 
layer { 
 name: "pool2" 
 type: "Pooling" 
 bottom: "conv2" 
 top: "pool2" 
 pooling_param { 
	  pool: MAX 
	  kernel_size: 2 
	  stride: 2 
 } 
} 
layer { 
 name: "ip1" 
 type: "InnerProduct" 
 bottom: "pool2" 
 top: "ip1" 
 param { 
	  name: "ip1_w" 
	  lr_mult: 1 
	  decay_mult: 0 
 } 
 param { 
	  name: "ip1_b" 
	  lr_mult: 2 
	  decay_mult: 0 
 } 
 inner_product_param { 
	  num_output: 500 
	  weight_filler { 
	 	  type: "xavier" 
	  } 
	  bias_filler { 
	 	  type: "constant" 
	  } 
 } 
} 
layer { 
 name: "relu1" 
 type: "ReLU" 
 bottom: "ip1" 
 top: "ip1" 
} 
layer { 
 name: "conv1_p" 
 type: "Convolution" 
 bottom: "data_p" 
 top: "conv1_p" 
 param { 
	  name: "conv1_w" 
	  lr_mult: 1 
	  decay_mult: 1 
 } 
 param { 
	  name: "conv1_b" 
	  lr_mult: 2 
	  decay_mult: 0 
 } 
 convolution_param { 
	  num_output: 20 
	  kernel_size: 5 
	  stride: 1 
	  weight_filler { 
	 	  type: "xavier" 
	  } 
	  bias_filler { 
	 	  type: "constant" 
	  } 
 } 
} 
layer { 
 name: "pool1_p" 
 type: "Pooling" 
 bottom: "conv1_p" 
 top: "pool1_p" 
 pooling_param { 
	  pool: MAX 
	  kernel_size: 2 
	  stride: 2 
 } 
} 
layer { 
 name: "conv2_p" 
 type: "Convolution" 
 bottom: "pool1_p" 
 top: "conv2_p" 
 param { 
	  name: "conv2_w" 
	  lr_mult: 1 
	  decay_mult: 1 
 } 
 param { 
	  name: "conv2_b" 
	  lr_mult: 2 
	  decay_mult: 0 
 } 
 convolution_param { 
	  num_output: 50 
	  kernel_size: 5 
	  stride: 1 
	  weight_filler { 
	 	  type: "xavier" 
	  } 
	  bias_filler { 
	 	  type: "constant" 
	  } 
 } 
} 
layer { 
 name: "pool2_p" 
 type: "Pooling" 
 bottom: "conv2_p" 
 top: "pool2_p" 
 pooling_param { 
	  pool: MAX 
	  kernel_size: 2 
	  stride: 2 
 } 
} 
layer { 
 name: "ip1_p" 
 type: "InnerProduct" 
 bottom: "pool2_p" 
 top: "ip1_p" 
 param { 
	  name: "ip1_w" 
	  lr_mult: 1 
	  decay_mult: 1 
 } 
 param { 
	  name: "ip1_b" 
	  lr_mult: 2 
	  decay_mult: 0 
 } 
 inner_product_param { 
	  num_output: 500 
	  weight_filler { 
	 	  type: "xavier" 
	  } 
	  bias_filler { 
	 	  type: "constant" 
	  } 
 } 
} 
layer { 
 name: "relu1_p" 
 type: "ReLU" 
 bottom: "ip1_p" 
 top: "ip1_p" 
} 
layer { 
 name: "concat" 
 type: "Concat" 
 concat_param { 
	  concat_dim: 1 
 } 
 bottom: "ip1" 
 bottom: "ip1_p" 
 top: "concat" 
} 
layer { 
 name: "feat1" 
 type: "InnerProduct" 
 bottom: "concat" 
 top: "feat1" 
 param { 
	  lr_mult: 1 
	  decay_mult: 1 
 } 
 param { 
	  lr_mult: 2 
	  decay_mult: 0 
 } 
 inner_product_param { 
	  num_output: 200 
	  weight_filler { 
	 	  type: "xavier" 
	  } 
	  bias_filler { 
	 	  type: "constant" 
	  } 
 } 
} 
layer { 
 name: "relu_feat" 
 type: "ReLU" 
 bottom: "feat1" 
 top: "feat1" 
} 
layer { 
 name: "transform_feat" 
 type: "InnerProduct" 
 bottom: "feat1" 
 top: "transform_feat" 
 param { 
	  lr_mult: 1 
	  decay_mult: 1 
 } 
 param { 
	  lr_mult: 2 
	  decay_mult: 0 
 } 
 inner_product_param { 
	  num_output: 3 
	  weight_filler { 
	 	  type: "xavier" 
	  } 
	  bias_filler { 
	 	  type: "constant" 
	  } 
 } 
} 
layer { 
 name: "classify_feat" 
 type: "InnerProduct" 
 bottom: "feat1" 
 top: "classify_feat" 
 param { 
	  lr_mult: 1 
	  decay_mult: 1 
 } 
 param { 
	  lr_mult: 2 
	  decay_mult: 0 
 } 
 inner_product_param { 
	  num_output: 10 
	  weight_filler { 
	 	  type: "xavier" 
	  } 
	  bias_filler { 
	 	  type: "constant" 
	  } 
 } 
} 
layer { 
 name: "classify_loss" 
 type: "SoftmaxWithLoss" 
 bottom: "classify_feat" 
 bottom: "classify_label" 
 top: "classify_loss" 
 loss_param { 
	  ignore_label: 10 
	  normalize: false 
 } 
 loss_weight: 10 
} 
layer { 
 name: "transform_loss" 
 type: "EuclideanLoss" 
 bottom: "transform_feat" 
 bottom: "transform_label" 
 top: "transform_loss" 
 loss_weight: 0 
} 
layer { 
 name: "classify_accuracy" 
 type: "Accuracy" 
 bottom: "classify_feat" 
 bottom: "classify_label" 
 top: "accuracy" 
 include { 
	  phase: TEST 
 } 
} 
